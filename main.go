// wpaste - easy code sharing
// Copyright (C) 2020  Evgeniy Rybin
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
package main

import (
	"bytes"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"time"

	"github.com/gorilla/mux"
	"go.etcd.io/bbolt"
)

const charset = "abcdefghijklmnopqrstuvwxyz" +
	"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

// RandomString creates a random string with the charset
// that contains all letters and digits
func RandomString(length int) string {
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[rand.Intn(len(charset))]
	}
	return string(b)
}

// OpenRandomNameFile creates a file in the directory dir,
// opens the file for reading and writing, and returns the resulting *os.File.
// The filename is generated by taking random string with length nameLen.
// Multiple programs calling OpenRandomNameFile simultaneously
// will not choose the same file. The caller can use f.Name()
// to find the pathname of the file.
func OpenRandomNameFile(dir string, nameLen int) (f *os.File, err error) {
	nconflict := 0
	for i := 0; i < 10000; i++ {
		name := filepath.Join(dir, RandomString(nameLen))
		f, err = os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0600)
		if os.IsExist(err) {
			if nconflict++; nconflict > 10 {
				rand.Seed(time.Now().UTC().UnixNano())
			}
			continue
		}
		break
	}
	return
}

// CreateUserFile creates a file with specified OR random name
func CreateUserFile(dir, name string) (servFile *os.File, err error) {
	if len(name) == 0 {
		servFile, err = OpenRandomNameFile(dir, 3)
	} else {
		name = filepath.Join(dir, name)
		servFile, err = os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0600)
	}
	return
}

// AddExpiresIn add file to db which expires in some time
func AddExpiresIn(ID, expires string) (int, error) {
	var exp int
	fmt.Sscanf(expires, "%d", &exp)
	if exp < 0 {
		return http.StatusBadRequest, errors.New("400 - Time shold be positive")
	}
	err := db.Update(func(tx *bbolt.Tx) error {
		b := tx.Bucket([]byte("expires"))
		expiresTime := time.Now().UTC().Add(time.Duration(exp) * time.Second).Unix()
		return b.Put([]byte(ID), []byte(strconv.FormatInt(expiresTime, 10)))
	})
	if err != nil {
		return http.StatusInternalServerError, errors.New("500 - Something bad happened")
	}
	return http.StatusOK, nil
}

// Help redirect to github
func Help(w http.ResponseWriter, r *http.Request) {
	http.Redirect(w, r, "https://github.com/waika28/wpaste.cyou", http.StatusSeeOther)
}

// UploadFile save file and response it ID
func UploadFile(w http.ResponseWriter, r *http.Request) {
	if r.ContentLength > 10<<20 {
		w.WriteHeader(http.StatusRequestEntityTooLarge)
		w.Write([]byte("413 - Max content size is 10MiB"))
		return
	}

	data := r.FormValue("f")
	file := bytes.NewReader([]byte(data))

	servFile, err := CreateUserFile(FilesDir, r.FormValue("name"))

	if os.IsExist(err) {
		w.WriteHeader(http.StatusConflict)
		w.Write([]byte("409 - This filename already taken!"))
		return
	} else if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte("500 - Something bad happened!"))
		return
	}

	defer servFile.Close()

	ID := filepath.Base(servFile.Name())

	expires := r.FormValue("e")
	if len(expires) != 0 {
		code, err := AddExpiresIn(ID, expires)
		if err != nil {
			w.WriteHeader(code)
			w.Write([]byte(err.Error()))
			return
		}
	}

	fileBytes, err := ioutil.ReadAll(file)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte("500 - Something bad happened!"))
		return
	}

	servFile.Write(fileBytes)

	w.Write([]byte(ID))
}

// SendFile respond file by it ID
func SendFile(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	ID := vars["id"]
	var expired bool
	err := db.View(func(tx *bbolt.Tx) error {
		b := tx.Bucket([]byte("expires"))
		expires := b.Get([]byte(ID))
		if expires != nil {
			var exp int64
			fmt.Sscanf(string(expires), "%d", &exp)
			expired = time.Now().UTC().After(time.Unix(exp, 0).UTC())
		}
		return nil
	})
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte("500 - Something bad happened!"))
		return
	}
	if expired {
		w.WriteHeader(http.StatusGone)
		fmt.Fprintf(w, "410 - File %v is no longer available", ID)
		return
	}
	file, err := ioutil.ReadFile(filepath.Join(FilesDir, ID))
	if err != nil {
		w.WriteHeader(http.StatusNotFound)
		fmt.Fprintf(w, "404 - File %v not found", ID)
		return
	}
	w.Write(file)
}

// WpasteRouter make router with all needed Handlers
func WpasteRouter() *mux.Router {
	Router := mux.NewRouter().StrictSlash(true)

	Router.HandleFunc("/", Help).Methods("GET")
	Router.HandleFunc("/", UploadFile).Methods("POST")

	Router.HandleFunc("/{id}", SendFile)
	return Router
}

// Working directory
var (
	FilesDir string
	BaseDir  string
)

// SetDirectories specify working directories
func SetDirectories() {
	var err error
	BaseDir, err = filepath.Abs(filepath.Dir(os.Args[0]))
	if err != nil {
		log.Fatal(err)
	}
	FilesDir = filepath.Join(BaseDir, "files")
}

var db *bbolt.DB

func initDB() {
	var err error
	db, err = bbolt.Open("data.db", 0600, nil)
	if err != nil {
		log.Fatal(err)
	}
	db.Update(func(tx *bbolt.Tx) error {
		_, err := tx.CreateBucketIfNotExists([]byte("expires"))
		return err
	})
	if err != nil {
		log.Fatal(err)
	}
}

// Install prepare to start:
// 1. Set working dirs
// 2. Make directory for user files
// 3. Set random seed
func Install() {
	SetDirectories()
	os.Mkdir(FilesDir, 0766)
	rand.Seed(time.Now().UTC().UnixNano())
	initDB()
}

// Close all connections
func Close() {
	db.Close()
}

func main() {
	Install()
	defer Close()
	http.ListenAndServe(":9990", WpasteRouter())
}
